// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@chainlink/contracts/src/v0.8/vrf/V2/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";

/**
 * @title RandomTxScheduler
 * @dev Contract to schedule transactions with verifiable randomness using Chainlink VRF.
 * This can be used by the MEV Protector to randomize transaction submission.
 */
contract RandomTxScheduler is VRFConsumerBaseV2 {
    VRFCoordinatorV2Interface immutable i_vrfCoordinator;
    uint64 immutable i_subscriptionId;
    bytes32 immutable i_keyHash;
    uint32 immutable i_callbackGasLimit;
    uint16 immutable i_requestConfirmations;
    uint32 immutable i_numWords;

    // Struct to hold details of a pending randomized transaction
    struct PendingTx {
        address target;
        bytes callData;
        uint256 value;
        uint256 requestId;
        uint256 scheduledTimestamp; // When the transaction is intended to be executed
        bool executed;
    }

    mapping(uint256 => PendingTx) public s_pendingRequests; // requestId => PendingTx
    uint256[] public s_requestIds; // To keep track of all requests

    // Event emitted when a VRF request is made
    event RandomnessRequested(uint256 indexed requestId, address indexed requester, uint256 timestamp);
    // Event emitted when randomness is received and a transaction is scheduled
    event TransactionScheduled(uint256 indexed requestId, address indexed target, uint256 scheduledTimestamp);
    // Event emitted when a scheduled transaction is executed
    event TransactionExecuted(uint256 indexed requestId, address indexed target, bool success);

    /**
     * @param _vrfCoordinator The address of the VRF Coordinator contract.
     * @param _subscriptionId The VRF subscription ID.
     * @param _keyHash The VRF key hash.
     * @param _callbackGasLimit The gas limit for the fulfillRandomWords callback.
     * @param _requestConfirmations The number of block confirmations to wait for.
     * @param _numWords The number of random words to request.
     */
    constructor(
        address _vrfCoordinator,
        uint64 _subscriptionId,
        bytes32 _keyHash,
        uint32 _callbackGasLimit,
        uint16 _requestConfirmations,
        uint32 _numWords
    ) VRFConsumerBaseV2(_vrfCoordinator) {
        i_vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);
        i_subscriptionId = _subscriptionId;
        i_keyHash = _keyHash;
        i_callbackGasLimit = _callbackGasLimit;
        i_requestConfirmations = _requestConfirmations;
        i_numWords = _numWords;
    }

    /**
     * @notice Requests randomness from Chainlink VRF to schedule a transaction.
     * @param _target The address of the contract to call.
     * @param _callData The calldata for the transaction.
     * @param _value The amount of native token to send with the transaction.
     * @return requestId The ID of the VRF request.
     */
    function requestRandomTxSchedule(
        address _target,
        bytes calldata _callData,
        uint256 _value
    ) external returns (uint256 requestId) {
        requestId = i_vrfCoordinator.requestRandomWords(
            i_keyHash,
            i_subscriptionId,
            i_requestConfirmations,
            i_callbackGasLimit,
            i_numWords
        );

        s_pendingRequests[requestId] = PendingTx({
            target: _target,
            callData: _callData,
            value: _value,
            requestId: requestId,
            scheduledTimestamp: 0, // Will be set in fulfillRandomWords
            executed: false
        });
        s_requestIds.push(requestId);

        emit RandomnessRequested(requestId, msg.sender, block.timestamp);
        return requestId;
    }

    /**
     * @notice Callback function called by Chainlink VRF Coordinator after randomness is generated.
     * @dev This function schedules the transaction based on the random word.
     * @param _requestId The ID of the VRF request.
     * @param _randomWords An array of random words generated by VRF.
     */
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        require(s_pendingRequests[_requestId].requestId != 0, "Request not found");
        require(s_pendingRequests[_requestId].scheduledTimestamp == 0, "Already scheduled");

        // Use the first random word to determine a delay (e.g., up to 60 seconds)
        uint256 delaySeconds = _randomWords[0] % 60; // Random delay between 0 and 59 seconds
        s_pendingRequests[_requestId].scheduledTimestamp = block.timestamp + delaySeconds;

        emit TransactionScheduled(_requestId, s_pendingRequests[_requestId].target, s_pendingRequests[_requestId].scheduledTimestamp);
    }

    /**
     * @notice Executes a scheduled transaction if its scheduled time has passed.
     * @param _requestId The ID of the VRF request associated with the transaction.
     */
    function executeScheduledTx(uint256 _requestId) external {
        PendingTx storage tx = s_pendingRequests[_requestId];
        require(tx.requestId != 0, "Transaction not found");
        require(tx.scheduledTimestamp != 0, "Transaction not yet scheduled by VRF");
        require(block.timestamp >= tx.scheduledTimestamp, "Transaction not yet due");
        require(!tx.executed, "Transaction already executed");

        tx.executed = true;
        (bool success, ) = tx.target.call{value: tx.value}(tx.callData);
        emit TransactionExecuted(_requestId, tx.target, success);
    }

    /**
     * @notice Allows an authorized agent (e.g., Chainlink Automation Keeper) to check if any transactions are due for execution.
     * @dev This function is designed to be called by Chainlink Automation.
     * @param _startIndex The index to start checking from in the s_requestIds array.
     * @param _maxCount The maximum number of requests to check.
     * @return upkeepNeeded True if there are transactions ready to be executed.
     * @return performData The encoded request IDs of transactions ready for execution.
     */
    function checkUpkeep(uint256 _startIndex, uint256 _maxCount) external view returns (bool upkeepNeeded, bytes memory performData) {
        uint256[] memory readyRequestIds = new uint256[](s_requestIds.length);
        uint256 count = 0;

        for (uint256 i = _startIndex; i < s_requestIds.length && count < _maxCount; i++) {
            uint256 requestId = s_requestIds[i];
            PendingTx storage tx = s_pendingRequests[requestId];
            if (tx.requestId != 0 && !tx.executed && tx.scheduledTimestamp != 0 && block.timestamp >= tx.scheduledTimestamp) {
                readyRequestIds[count] = requestId;
                count++;
            }
        }
        upkeepNeeded = count > 0;
        performData = abi.encode(readyRequestIds, count);
    }

    /**
     * @notice Executes the transactions identified by checkUpkeep.
     * @dev This function is designed to be called by Chainlink Automation.
     * @param _performData The encoded request IDs of transactions to execute.
     */
    function performUpkeep(bytes calldata _performData) external {
        (uint256[] memory readyRequestIds, uint256 count) = abi.decode(_performData, (uint256[], uint256));

        for (uint256 i = 0; i < count; i++) {
            executeScheduledTx(readyRequestIds[i]);
        }
    }
}
